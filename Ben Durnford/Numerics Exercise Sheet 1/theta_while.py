import numpy as np
import matplotlib.pyplot as plt


np.random.seed(11)

#defines global parameters
L=-1
L_p=1  #the dimensions of the box
N=100 #number of timesteps
J=20000 #number of elements x is split into
dx=(L_p-L)/J  #size of each x element
print(f'dx is {dx}')

T=1.0
dt=T/N  #size of each timestep
mu=dt/(dx**2)
print(f'mu is {mu}')
theta=1.0
beta=theta*mu   
epsilon=1.0E-0  #the size of the diffusion coefficient

#define the initial conditions and a(t) as functions

def spike(x):  #function which is linear and symmetric around its midpoint
    y=np.zeros(len(x))
    for i,val in enumerate(x):
        if val <=L+(L-L_p)/2:
            y[i]+=2*val
        elif val>=L+(L-L_p)/2:
            y[i]+=2-(2*val)
    return y

'''The first function which is mentioned in question 6 '''

def f_1(x):
    y=(1-x)**4 * (1+x)
    return y

'''A similar function to f_1 except it is multiplied by a sum of Legendre polynomials with random coefficients b_k.
These coefficients are generated by np.random and I have specifically set the seed to 11 in order to ensure that
the results are comparable with each other.'''

def f_2(x):
    y=(1-x)**4 * (1+x)
    b=np.random.random_sample(4)
    print(f'The b values are {b}')
    leg_0=1*b[0]
    leg_1=x*b[1]
    leg_2=(1.5*x**2-0.5)*b[2]
    leg_3=(2.5*x**3-1.5*x)*b[3]
    leg_sum=leg_0+leg_1+leg_2+leg_3
    C=np.min(leg_sum)
    if C<=0:
        leg_sum-=C
    fn=y*leg_sum
    return fn

'''The advection coefficient. Here, we have set a to be a constant 
but this can be easily altered to produce more interesting flows'''

def a(t):  
    return 1.0

#initiate the velocity field at time 0

U=np.zeros(J+1) 
x=np.array([L+i*dx for i in range(0,J+1)])  #x coordinates
A=np.zeros(J+1)
e=np.zeros(J+1)
f=np.zeros(J+1)

#to change the initial conditions, change the function that is called by the line below
U=spike(x)
print(U)


times = np.linspace(0,T,5) #saves the data for graphing
data=np.zeros((len(times),J+1))
cond=[True for i in range(len(times))]
data[0,:]=U
print(U)

#finite difference algorithm which is based on the Thomas algorithm
'''Finite difference algorithm which is based upon the Thomas algorithm. It works by converting the
matrix system into upper triangular form and recursively altering the '''

t=0
i=0
m=1
while t<=T:
    t+=dt
    e[0]=0.0
    f[0]=0.0

    #creates the arrays e[j] and f[j] which are used to update the spatial 

    for j in range(1,J):
        dnm=(1+beta*(2*epsilon-epsilon*e[j-1]+a(t+dt)*dx))
        e[j]=(theta*mu*(epsilon+a(t+dt)*dx))/dnm
        fnum=U[j]+mu*(1-theta)*(epsilon*(U[j+1]-2*U[j]+U[j-1])+dx*a(t)*(U[j+1]-U[j]))+mu*epsilon*theta*f[j-1]
        f[j]=fnum/dnm


    for j in reversed(range(1,J)):
        U[j]=f[j]+e[j]*U[j+1]
 

    if t>times[m]:
        data[m,:]+=U[:]
        m+=1
    
#graphs the data. 

colors = plt.cm.viridis(np.linspace(0.1,0.9,len(times)))  #the color scheme used within my graphs
fig2,ax2=plt.subplots()
for i in range(0,len(times)):
    ax2.plot(x,data[i,:],color=colors[i],label=f'{round(times[i],2)}')  #plots a velocity curve for each time within the array times 
    
ax2.set(ylabel='Fluid velocity, U',xlabel='Position, x',xlim=(-1.0,1.0),ylim=(0.0,2.5))  #sets the domain of the graph and the graph labels
ax2.legend(title='Time , t',frameon=False, loc='upper left',ncols=2)  #creates a legend
plt.show()

